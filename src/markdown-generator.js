import path from 'path';

export class MarkdownGenerator {
  constructor(config) {
    this.config = config;
  }

  generateMarkdownFilename(commit) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const shortHash = commit.hash.substring(0, 8);
    const sanitizedMessage = commit.message
      .replace(/[^a-zA-Z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .toLowerCase()
      .substring(0, 50);
    
    return `${timestamp}-${shortHash}-${sanitizedMessage}.md`;
  }

  generateMarkdownContent(review, commit, diff) {
    const timestamp = new Date().toISOString();
    
    let markdown = `# Code Review Report\n\n`;
    markdown += `**Generated:** ${timestamp}\n`;
    markdown += `**Commit:** ${commit.hash}\n`;
    markdown += `**Author:** ${commit.author}\n`;
    markdown += `**Date:** ${commit.date}\n`;
    markdown += `**Message:** ${commit.message}\n\n`;
    
    markdown += `---\n\n`;
    
    // Scores
    if (review.score !== undefined || review.confidence !== undefined) {
      markdown += `## 📊 Review Scores\n\n`;
      if (review.score !== undefined) {
        const scoreEmoji = review.score >= 8 ? '🟢' : review.score >= 6 ? '🟡' : '🔴';
        markdown += `- **Code Quality Score:** ${scoreEmoji} ${review.score}/10\n`;
      }
      if (review.confidence !== undefined) {
        const confidenceEmoji = review.confidence >= 8 ? '🟢' : review.confidence >= 6 ? '🟡' : '🔴';
        markdown += `- **AI Confidence Level:** ${confidenceEmoji} ${review.confidence}/10\n`;
      }
      markdown += `\n`;
    }
    
    // Summary
    if (review.summary) {
      markdown += `## 📋 Summary\n\n${review.summary}\n\n`;
    }
    
    // Issues
    if (review.issues && review.issues.length > 0) {
      markdown += `## ⚠️ Issues Found\n\n`;
      review.issues.forEach((issue, i) => {
        const severityEmoji = {
          'critical': '🚨',
          'high': '⚠️',
          'medium': '⚡',
          'low': 'ℹ️'
        }[issue.severity] || '⚠️';
        
        markdown += `### ${i + 1}. ${severityEmoji} ${issue.severity.toUpperCase()}: ${issue.description}\n\n`;
        
        if (issue.suggestion) {
          markdown += `**💡 Suggestion:** ${issue.suggestion}\n\n`;
        }
        if (issue.category) {
          markdown += `**🏷️ Category:** ${issue.category}\n\n`;
        }
        if (issue.citation) {
          markdown += `**📚 Source:** ${issue.citation}\n\n`;
        }
        if (issue.autoFixable) {
          markdown += `**🔧 Auto-fixable:** Yes\n\n`;
        }
        markdown += `---\n\n`;
      });
    }
    
    // Suggestions
    if (review.suggestions && review.suggestions.length > 0) {
      markdown += `## 💡 General Suggestions\n\n`;
      review.suggestions.forEach((suggestion, i) => {
        markdown += `${i + 1}. ${suggestion}\n`;
      });
      markdown += `\n`;
    }
    
    // Security Notes
    if (review.security && review.security.length > 0) {
      markdown += `## 🔒 Security Notes\n\n`;
      review.security.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Performance Notes
    if (review.performance && review.performance.length > 0) {
      markdown += `## ⚡ Performance Notes\n\n`;
      review.performance.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Dependency Notes
    if (review.dependencies && review.dependencies.length > 0) {
      markdown += `## 📦 Dependency Notes\n\n`;
      review.dependencies.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Accessibility Notes
    if (review.accessibility && review.accessibility.length > 0) {
      markdown += `## ♿ Accessibility Notes\n\n`;
      review.accessibility.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Sources Consulted
    if (review.sources && review.sources.length > 0) {
      markdown += `## 📚 Sources Consulted\n\n`;
      review.sources.forEach((source, i) => {
        markdown += `${i + 1}. ${source}\n`;
      });
      markdown += `\n`;
    }
    
    // Code Diff
    if (diff && this.config.includeDiffInMarkdown !== false) {
      markdown += `## 📝 Code Changes\n\n`;
      markdown += `\`\`\`diff\n${diff}\n\`\`\`\n\n`;
    }
    
    // Footer
    markdown += `---\n\n`;
    markdown += `*Generated by AI PR Reviewer using ${this.config.aiProvider} (${this.config.model})*\n`;
    
    return markdown;
  }

  generateRepositoryMarkdownContent(review, files, combinedContent) {
    const timestamp = new Date().toISOString();
    
    let markdown = `# Repository Code Review Report\n\n`;
    markdown += `**Generated:** ${timestamp}\n`;
    markdown += `**Review Type:** Repository Review\n`;
    if (review.groupIndex && review.totalGroups) {
      markdown += `**Group:** ${review.groupIndex} of ${review.totalGroups}\n`;
    }
    markdown += `**Files Reviewed:** ${files.length}\n\n`;
    
    // List files
    markdown += `## 📁 Files in This Review\n\n`;
    files.forEach((file, i) => {
      markdown += `${i + 1}. \`${file}\`\n`;
    });
    markdown += `\n---\n\n`;
    
    // Scores
    if (review.score !== undefined || review.confidence !== undefined) {
      markdown += `## 📊 Review Scores\n\n`;
      if (review.score !== undefined) {
        const scoreEmoji = review.score >= 8 ? '🟢' : review.score >= 6 ? '🟡' : '🔴';
        markdown += `- **Code Quality Score:** ${scoreEmoji} ${review.score}/10\n`;
      }
      if (review.confidence !== undefined) {
        const confidenceEmoji = review.confidence >= 8 ? '🟢' : review.confidence >= 6 ? '🟡' : '🔴';
        markdown += `- **AI Confidence Level:** ${confidenceEmoji} ${review.confidence}/10\n`;
      }
      markdown += `\n`;
    }
    
    // Summary
    if (review.summary) {
      markdown += `## 📋 Summary\n\n${review.summary}\n\n`;
    }
    
    // Issues
    if (review.issues && review.issues.length > 0) {
      markdown += `## ⚠️ Issues Found\n\n`;
      review.issues.forEach((issue, i) => {
        const severityEmoji = {
          'critical': '🚨',
          'high': '⚠️',
          'medium': '⚡',
          'low': 'ℹ️'
        }[issue.severity] || '⚠️';
        
        markdown += `### ${i + 1}. ${severityEmoji} ${issue.severity.toUpperCase()}: ${issue.description}\n\n`;
        
        if (issue.suggestion) {
          markdown += `**💡 Suggestion:** ${issue.suggestion}\n\n`;
        }
        if (issue.category) {
          markdown += `**🏷️ Category:** ${issue.category}\n\n`;
        }
        if (issue.citation) {
          markdown += `**📚 Source:** ${issue.citation}\n\n`;
        }
        if (issue.autoFixable) {
          markdown += `**🔧 Auto-fixable:** Yes\n\n`;
        }
        markdown += `---\n\n`;
      });
    }
    
    // Add other sections (suggestions, security, performance, etc.)
    markdown = this.addCommonSections(markdown, review);
    
    // Code Content (if not too large)
    if (combinedContent && this.config.includeDiffInMarkdown !== false && combinedContent.length < 50000) {
      markdown += `## 📝 Reviewed Code\n\n`;
      markdown += `${combinedContent}\n\n`;
    } else if (combinedContent && combinedContent.length >= 50000) {
      markdown += `## 📝 Reviewed Code\n\n`;
      markdown += `*Content too large to include in markdown (${combinedContent.length} characters)*\n\n`;
    }
    
    // Footer
    markdown += `---\n\n`;
    markdown += `*Generated by AI PR Reviewer using ${this.config.aiProvider} (${this.config.model})*\n`;
    
    return markdown;
  }

  generateCommitSummaryMarkdown(summaryData, options) {
    const timestamp = new Date().toISOString();
    
    let markdown = `# Commit History Review Summary\n\n`;
    markdown += `**Generated:** ${timestamp}\n`;
    markdown += `**Review Type:** All Commits Review\n`;
    markdown += `**Total Commits Analyzed:** ${summaryData.totalCommitsReviewed}\n\n`;
    
    // Add applied filters
    if (options.since || options.until || options.author || options.branch !== 'HEAD') {
      markdown += `## 🔍 Applied Filters\n\n`;
      if (options.since) markdown += `- **Since:** ${options.since}\n`;
      if (options.until) markdown += `- **Until:** ${options.until}\n`;
      if (options.author) markdown += `- **Author:** ${options.author}\n`;
      if (options.branch && options.branch !== 'HEAD') markdown += `- **Branch:** ${options.branch}\n`;
      markdown += `\n`;
    }
    
    // Contributors
    markdown += `## 👥 Contributors\n\n`;
    markdown += `| Rank | Author | Commits | Percentage |\n`;
    markdown += `|------|--------|---------|------------|\n`;
    summaryData.authors.forEach(([author, count], i) => {
      const percentage = ((count / summaryData.totalCommitsReviewed) * 100).toFixed(1);
      markdown += `| ${i + 1} | ${author} | ${count} | ${percentage}% |\n`;
    });
    markdown += `\n`;
    
    // Monthly Activity
    if (summaryData.monthlyActivity.length > 0) {
      markdown += `## 📅 Monthly Activity\n\n`;
      markdown += `| Month | Commits |\n`;
      markdown += `|-------|---------|\n`;
      summaryData.monthlyActivity.forEach(([month, count]) => {
        markdown += `| ${month} | ${count} |\n`;
      });
      markdown += `\n`;
    }
    
    // Commit Types
    if (summaryData.commitTypes.length > 0) {
      markdown += `## 🏷️ Commit Type Analysis\n\n`;
      markdown += `| Rank | Type | Count | Percentage |\n`;
      markdown += `|------|------|-------|-----------|\n`;
      summaryData.commitTypes.forEach(([type, count], i) => {
        const percentage = ((count / summaryData.totalCommitsReviewed) * 100).toFixed(1);
        markdown += `| ${i + 1} | \`${type}\` | ${count} | ${percentage}% |\n`;
      });
      markdown += `\n`;
    }
    
    // Footer
    markdown += `---\n\n`;
    markdown += `*Generated by AI PR Reviewer using ${this.config.aiProvider} (${this.config.model})*\n`;
    markdown += `*Individual commit reviews are saved in separate files in the same directory*\n`;
    
    return markdown;
  }

  addCommonSections(markdown, review) {
    // Suggestions
    if (review.suggestions && review.suggestions.length > 0) {
      markdown += `## 💡 General Suggestions\n\n`;
      review.suggestions.forEach((suggestion, i) => {
        markdown += `${i + 1}. ${suggestion}\n`;
      });
      markdown += `\n`;
    }
    
    // Security Notes
    if (review.security && review.security.length > 0) {
      markdown += `## 🔒 Security Notes\n\n`;
      review.security.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Performance Notes
    if (review.performance && review.performance.length > 0) {
      markdown += `## ⚡ Performance Notes\n\n`;
      review.performance.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Dependency Notes
    if (review.dependencies && review.dependencies.length > 0) {
      markdown += `## 📦 Dependency Notes\n\n`;
      review.dependencies.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Accessibility Notes
    if (review.accessibility && review.accessibility.length > 0) {
      markdown += `## ♿ Accessibility Notes\n\n`;
      review.accessibility.forEach((note, i) => {
        markdown += `${i + 1}. ${note}\n`;
      });
      markdown += `\n`;
    }
    
    // Sources Consulted
    if (review.sources && review.sources.length > 0) {
      markdown += `## 📚 Sources Consulted\n\n`;
      review.sources.forEach((source, i) => {
        markdown += `${i + 1}. ${source}\n`;
      });
      markdown += `\n`;
    }
    
    return markdown;
  }
}